// Declara el objeto global que será inyectado por vite.config.ts
declare const importMetaEnv: Record<string, string>;

import { GoogleGenAI, Type, Modality } from "@google/genai";
import { RecipeSuggestion } from '../types';

// Lee la variable desde el objeto global personalizado.
const geminiApiKey = importMetaEnv.VITE_GEMINI_API_KEY;

if (!geminiApiKey) {
    throw new Error("VITE_GEMINI_API_KEY is not defined. Please set the VITE_GEMINI_API_KEY environment variable in your Vercel project settings.");
}

const ai = new GoogleGenAI({ apiKey: geminiApiKey });

const recipeSchema = {
    type: Type.OBJECT,
    properties: {
        title: {
            type: Type.STRING,
            description: "El nombre creativo y atractivo de la receta."
        },
        ingredients: {
            type: Type.ARRAY,
            description: "Una lista de todos los ingredientes necesarios para la receta, incluyendo cantidades.",
            items: {
                type: Type.STRING
            }
        },
        steps: {
            type: Type.ARRAY,
            description: "Una guía paso a paso para preparar y cocinar el plato.",
            items: {
                type: Type.STRING
            }
        },
    },
    required: ['title', 'ingredients', 'steps']
};

export const suggestRecipe = async (prompt: string): Promise<RecipeSuggestion> => {
    try {
        const systemInstruction = `Eres un chef creativo dentro de un recetario digital hecho con amor. Tu nombre es Asistente de Gaba. Tu objetivo es proporcionar una receta maravillosa basada en la solicitud del usuario. Sé cálido y alentador en tus respuestas.`;

        const response = await ai.models.generateContent({
            model: "gemini-2.5-flash",
            contents: prompt,
            config: {
                systemInstruction,
                responseMimeType: "application/json",
                responseSchema: recipeSchema,
            },
        });
        
        const jsonText = response.text.trim();
        const parsedJson = JSON.parse(jsonText);
        
        if (!parsedJson.title || !Array.isArray(parsedJson.ingredients) || !Array.isArray(parsedJson.steps)) {
            throw new Error("Invalid recipe format received from API.");
        }

        return parsedJson as RecipeSuggestion;
    } catch (error) {
        console.error("Error fetching recipe from Gemini API:", error);
        throw new Error("Lo siento, tuve problemas para crear una receta. ¡Por favor, inténtalo de nuevo!");
    }
};

export const generateRecipeImage = async (recipeTitle: string): Promise<string> => {
    try {
        const prompt = `A delicious, mouth-watering, professional food photograph of '${recipeTitle}', presented beautifully on a plate, ready to be served. Centered, vibrant colors, appetizing.`;

        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash-image',
            contents: {
                parts: [{ text: prompt }],
            },
            config: {
                responseModalities: [Modality.IMAGE],
            },
        });

        for (const part of response.candidates[0].content.parts) {
            if (part.inlineData) {
                return part.inlineData.data; // This is the base64 string
            }
        }

        throw new Error("No image was generated by the API.");

    } catch (error) {
        console.error("Error generating recipe image with Gemini:", error);
        // Fallback to a placeholder if image generation fails
        return ''; // Return empty string to signal fallback
    }
};